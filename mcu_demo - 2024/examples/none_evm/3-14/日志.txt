12-30：
  将原来的模拟定时器来生成跳绳的次数，我使用真实的跳绳来代替。
原来使用在软件定时器里面进行，检测电平，这个方法感觉不太好。我开启了gpio的中断来显示，按钮我也用了中断来享受。


pmu_port_wakeup_func_set(GPIO_PC5|GPIO_PC6|GPIO_PC7); //这是PMU的中断，对应函数为pmu_gpio_isr_ram



在中断
//co_printf("K:0x%08x\r\n", (pressed_key));  //自己加的
	switch(pressed_key)
	{
		case 0x00300000:
		{
			uart_Read(NULL);
			break;
		}
		case 0x00d00000:
		{
			
			element_verify(pressed_key);
			break;
		}
		default:
			break;
	}



最后，可以正常的计数了。


1-4：
我想原来的os_timer_init(&read_timer, read_handler,NULL);	//读取输出换成中断的下半段
来减少触发，还没完成。
最后，我看看他的封装与发送，好麻烦


1-5：
我已经完成了用硬件来定时，可能还是有一点不准。但是好多了。
我打算最后用RTC来计数这样会好一点。
、

1-10：
昨天把NB发送改了，改为一次性发送完成的。可以用。但是无法确定有没有发送成功。


1-11：
已经把时间戳的问题解决了，用的是秒，将一个32位的数，拆分改为两个16位来加减。

1-12：
更改原来的蓝牙通信的问题，要改MTU的值

1-18：
利用记住NUM和COUNT来实现，NB数据的存储，但是有时候会存错。还有

1-19
完成了蓝牙数据的分包发送，要先将字符数据变成uint8_t的整形，在有两个函数来完成分包。

1-23：
蓝牙分包已经完成了，nb的发送也解决了。flash_writh不能存储uint16字节，要分开存储。

